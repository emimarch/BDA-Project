---
title: "BDA-Project"
output: html_document
date: "2022-11-10"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
```{r, include=FALSE}
library(cmdstanr)
check_cmdstan_toolchain(fix = TRUE, quiet = TRUE)
```

## Introduction 

-the motivation

For our Bayesian Data Analysis Project, we aim to 

-the problem
-and the main modeling idea.
-Showing some illustrative figure is recommended.

## Data

### Data preprocessing

We collected the total number of Ebola cases from the Ebola dataset provided by WHO and shared by humandata.org (we use ebola_data_db_format.csv from https://data.humdata.org/dataset/ebola-cases-2014). The ebola cases we use in our project are an aggregate of suspected, confirmed and probable ebola cases, which are based on official information reported by ministries of health. The priginal dataset contains figures for ten countries: 	
Guinea,  Italy,  Liberia,  Mali,  Nigeria,  Senegal,  Sierra Leone,  Spain,  United Kingdom,  United States. Each country spans it own date range of varying length between the end 2014 to the beginning of 2016, therefore we have different number of observations for each country. The case count is usually provided every 1 to 3 days (although the periodicity varies by country), that we aggregate into monthly figures. We did so by assigning the month value of 0 to the first date that appears in the dataset, and calculate the the other month values as the month difference from the first date. The first date in our dataset was 2014-08-29 for Guinea, so all observations occuring 30 days after that have month difference value 0. The observations with date 2015-12-29 for the United States, on the other hand, has month_diff value 15 because the difference in time between this date and the first date in our dataset is 15 months.
We aggregated this data with the population density for each country at the given date. We use the population density from the WorldBank database. The population density can only access as a yearly figure. Therefore,using the previous example of the United states with month_diff value 15 calculated from date 2015-12-29, the pop_dens value will represent the population density of the United States in 2015. 

## Processed dataset

The final dataset contains 165 entries and three columns : Country, Cases, Months\_diff, and Pop\_dens. Months_diff is the number of months from the earliest data we could access cases information on, that is 2014-08-29 for Guinea. Country is a country among the 10 we selected. Cases is the aggregate of suspected, confirmed and propable ebola cases for the given Country during the given months_diff, and pop_den is yearly population density that the country had during the given months_diff.


```{r}
data <- read.csv(file = 'ebola_population_aggregate_same_span.csv')
head(data)
```
```{r}
str(data)
```


The following line shows the number of observations per country, where each observation represents a value of the months_diff. As can be observed and as was mentioned before, the number of observations per country differ because the cases were not provided for the same date spans for all countries. For instance, the ebola dataset from human_data.org included only dates from 2015-05-14 to 2016-03-23 for Italy (which correspond to month_diff 8 to 18) with cases unreported for several months too. Meanwhile, the cases for Guinea were given from 2014-08-29 (month_diff = 0) to 2016-03-23 (month_diff = 18). 


```{r}
table(data$Country)
```
A more illustrative representation of the dataset can be seen from the scatter plots of below. In the top panels, we do not distinguish between countries. In the bottom panels, we differentiate between the observations of different countries by color. 

```{r}
library("ggplot2")
#install.packages("gridExtra") 
library("gridExtra")

pa<-ggplot(data,aes(x=months_diff,y=Cases))+geom_point(size=1, position = "jitter")
qa <- ggplot(data,aes(x=months_diff,y=Pop_den))+geom_point(size=1, position = "jitter")
grid.arrange(pa,qa,ncol=2)
```
```{r}
p<-ggplot(data,aes(x=months_diff,y=Cases,col=Country))+geom_point(size=1,position = "jitter")+theme(legend.position="bottom", legend.text = element_text(size=3))
q <- ggplot(data,aes(x=months_diff,y=Pop_den,col=Country))+geom_point(size=1,position = "jitter")+theme(legend.position="bottom", legend.text = element_text(size=3))
grid.arrange(p,q,ncol=2)

```

As can be observed from the panels above, there is obvious relationship between the country and the cases count by month. This will come to show that the pooled model will not accurately fit our data, because of this dependency of the country and the cases. On the other hand, a hierarchical model that differentiates between countries, will result in a significantly better fit, although a separate model might perform even better. 

## Models 

The models we settled on are inspired by the Bayesian analysis on the motivational shifts in agin monkeys (add citation here). Similarly to their analysis on monkeys, our grouping variable is the country, which indicates to what group the observation belongs. We have one group-level covarity, which is the population density of the country. This does not vary at every observation, but changes by minimal amounts every year. Since the changes in density are very small for each country, we can say that population density is almost constant for each country and identify it as a group-level covarity. Lastly, our individual-level covarity is the month_diff variable, as it varies with the individual observations. We will run a pooled analysis and a hierarchical analysis on this dataset to evaluate which approach returns the best posterior predictive distribution.  

### Pooled

In the pooled approach, we assume that there is no difference between countries. We therefore consider the dataset of observations as a whole, and assume that in a linear regression approach the coefficient and parameters are shared among the countries. Let's assume that our Case observations $j$ can be modeled as normal distribution whose mean depends on the month_diff and the population density. This is shown as reported below: 

$$

Cases_j \sim N(\mu + \beta_{pop\_den}pop\_den_{j} + \beta_{month\_diff}month\_diff + \beta_{pop\_den,month\_diff} pop\_den \times month\_diff, \sigma^2)
$$
Following the pooled model approach, the parameter $\mu$, $\beta_{pop\_den}$, $\beta_{month\_diff}$, $\beta_{pop\_den,month\_diff}$ and $\sigma$ defining the normal distribution are drawn from the same prior distributions for every observation $\Cases_j$. 

We want weakly information or uninformative priors for this model, as long as they are proper priors. More information on prior choices will be given in the "Prior choices" section. We define these priors as: 

$$

\mu \sim N(0, 10000)\\
\beta_{pop\_den} \sim N(5000, 2000) \\
\beta_{month\_diff} \sim N(5000, 2000)\\
\beta_{pop\_den, month\_diff} \sim N(5000, 2000)\\
\sigma \sim gamma(1,1)
$$
The stan model is reported below: 

```{stan output.var='pooled'}
data {
  int<lower=0> N; // number of observations
  vector[N] month; //vector of months_diff
  vector[N] pop_den; //population density
  vector[N] cases;
}

parameters {
  real mu;
  real beta_month;
  real beta_pop;
  real beta_month_pop;
  real<lower=0> sigma;
}

model {

  // Priors
  mu ~ normal(0, 10000);
  beta_month ~ normal(5000, 2000);
  beta_pop ~ normal(5000,2000);
  beta_month_pop ~ normal(5000,2000);
  sigma ~ gamma(1, 1);
  

  for (i in 1:N){
    cases[i] ~ normal(mu + beta_month*month[i] + beta_pop*pop_den[i] + beta_month_pop*month[i]*pop_den[i], sigma);
  }
}

generated quantities {
  real ypred;
  vector[N] log_lik;
  
  ypred = normal_rng(mu, sigma); // pooled predictive distribution 
  
  for(i in 1:N)
    {
      log_lik[i] = normal_lpdf(cases[i] | mu + beta_month*month[i] + beta_pop*pop_den[i] + beta_month_pop*month[i]*pop_den[i], sigma);
   }

}

```


```{r}
stan_data <- list(
  cases = data$Cases,
  N = nrow(data),
  month=data$months_diff,
  pop_den=data$Pop_den
)
pooled_model <- rstan::sampling(pooled, data = stan_data)
pooled_draws <- rstan::extract(pooled_model)
```


### Hierarchical

In the hierarchical approach, we do not assume shared priors as in the pooled approach, neither completely distinguished group level priors as in the separate approach, but we differentiate between countries by assigning each country its own prior that's sampled from the same hyper-prior distribution for each country. This should allow some differentiation between countries while maintaining a level of dependency among all observations by sampling from the same hyper-priors. We can then say that we can model the number of cases for country $i$ in month\_diff $j$ as reported below: 


$$

Cases_{ij}| \mu_j, \beta, \sigma \sim N(\mu_j + \beta_{pop\_den_j} pop\_den_{ij} + \beta_{month_j}month_{ij} + \beta_{month, pop\_den_j} month_{ij} \times pop\_den_{ij}, \sigma^2)\\

\\
\\
\text{Priors}\\
\\
\\
\\
\sigma \sim gamma(1,1)\\
\mu_j \sim N(\mu_h,\tau)\\
\beta_{pop\_den_j} \sim N(\beta_{hpop\_den}, \tau_{hpop\_den})\\
\beta_{month, pop\_den_j}\sim N(\beta_{hmonth, pop\_den}, \tau_{hmonth,pop})\\
\beta_{month_j}\sim N(\beta_{hmonth}, \tau_{month})\\
\\
\\
\\
\text{Hyperprios}\\
\\
\\
\mu_h \sim N(0, 10000) \\
\tau \sim gamma(1,1) \\

\beta_{hpop\_den} \sim N(2000, 50000)\\
\beta_{hmonth, pop\_den} \sim N(2000, 50000)\\
\beta_{hmonth} \sim N(2000, 30000)\\

\tau_{hpop\_den} \sim gamma(1,1)\\
\tau_{hmonth,pop\_den} \sim gamma(1,1)\\
\tau_{month} \sim gamma(1,1)\\


$$


```{stan output.var='hierarchical'}
data {
  int<lower=0> M; //number of countries
  int<lower=0> N;//max number of obs across all the countries
  
  vector[M] month[N];//vector of months
  vector[M] pop_den[N];//population density
  vector[M] cases[N];
  
}

parameters {
  vector[M] mu;
  vector[M] beta_month;
  vector[M] beta_pop;
  vector[M] beta_month_pop;
  real<lower=0>sigma;
  real<lower=0> tau;
  real hyper_mu;
  real hyper_beta_month;
  real hyper_beta_pop;
  real hyper_beta_month_pop;
 
}

model {

  tau ~ gamma(1,1);
  sigma ~ gamma(1,1);
  hyper_mu ~ normal(0, 10000);
  hyper_beta_pop ~ normal(2000,5000);
  hyper_beta_month ~ normal(2000,5000);
  hyper_beta_month_pop ~ normal(2000,5000);

  for (j in 1:M){
    mu[j] ~ normal(hyper_mu, tau);
    beta_month[j] ~ normal(hyper_beta_month, tau);
    beta_pop[j] ~ normal(hyper_beta_pop, tau);
    beta_month_pop[j] ~ normal(hyper_beta_month_pop, tau);
  
    for (n in 1:N){
      cases[n,j] ~ normal(mu[j] + beta_month[j]*month[n,j] + beta_pop[j]*pop_den[n,j] + beta_month_pop[j]*month[n,j]*pop_den[n,j], sigma);
    }
  }
}

generated quantities {
  
  vector[M] log_lik[N];
  
  for (j in 1:M){
    for(i in 1:N){
      log_lik[i,j] = normal_lpdf(cases[i,j] | mu[j] + beta_month[j]*month[i,j] + beta_pop[j]*pop_den[i,j] + beta_month_pop[j]*month[i,j]*pop_den[i,j], sigma);
   }
  }
}



```




```{stan output.var='hierarchical_mod'}
data {
  int<lower=0> M; //number of countries
  int<lower=0> N;//max number of obs across all the countries
  
  vector[M] month[N];//vector of months
  vector[M] pop_den[N];//population density
  vector[M] cases[N];
  
}

parameters {
  vector[M] mu;
  real beta_month;
  real beta_pop;
  real beta_month_pop;
  real<lower=0>sigma;
  real<lower=0> tau;
  real hyper_mu;

 
}

model {

  tau ~ gamma(1,1);
  sigma ~ gamma(1,1);
  hyper_mu ~ normal(0, 10000);
  beta_month ~ normal(5000, 2000);
  beta_pop ~ normal(5000,2000);
  beta_month_pop ~ normal(5000,2000);

  for (j in 1:M){
    mu[j] ~ normal(hyper_mu, tau);
  
    for (n in 1:N){
      cases[n,j] ~ normal(mu[j] + beta_month*month[n,j] + beta_pop*pop_den[n,j] + beta_month_pop *month[n,j]*pop_den[n,j], sigma);
    }
  }
}

generated quantities {
  
  vector[M] log_lik[N];
  
  for (j in 1:M){
    for(i in 1:N){
      log_lik[i,j] = normal_lpdf(cases[i,j] | mu[j] + beta_month*month[i,j] + beta_pop *pop_den[i,j] + beta_month_pop *month[i,j]*pop_den[i,j], sigma);
   }
  }
}



```
```{r}
#make_dataframe = function(col_name, df){
  #new_df = data.frame(matrix(nrow=8))
  
  #for (country in Countries){
    #new_country_col <- df[df$Country == country, col_name]
    #n_obs <- length(new_country_col)
    #new_df[country] <- c(new_country_col, rep(-200, max_obs-n_obs))
  #}
  #return(new_df[,2:length(new_df)])
#}


months<- matrix(nrow = 8, ncol = 17)
pop_den <- matrix(nrow = 8, ncol = 17)
cases <- matrix(nrow = 8, ncol = 17)


row_count <- 1
for (i in 1:8){
  for (j in 1:17){
    #print(i)
    #print(j)
    months[i,j] = data$months_diff[row_count]
    pop_den[i,j] = data$Pop_den[row_count]
    cases[i,j] = data$Cases[row_count]
    row_count <- row_count + 1 
  }
}


```

```{r}
stan_data_hier <- list(
  cases = t(cases),
  N = 17,
  M = 8,
  month=t(months),
  pop_den=t(pop_den)
)
hier_d <- cmdstan_model(stan_file = "hier.stan")
model_hierarchical <- hier_d$sample(data = stan_data_hier, refresh=1000)

```



## Prior choices


## Convergence analysis

!Note: add about ESS

In this section, we evaluate that our models have reached convergence by observing the value of $\hat{R}$. If this parameter is close to 1, we can safely assume that our MCMC has reached convergence. 

### Pooled 

```{r}
summary(pooled_model)
```

### Hierarchical

```{r}

```

## Model selection 


```{r}
library("loo")

loo_pooled <- loo(pooled_model,save_psis=TRUE)
print(loo_pooled)

plot(loo_pooled)

```

```{r}

loo_hier<- model_hierarchical$loo()
print(loo_hier)

plot(loo_hier)

print(loo_hier$elpd_loo)
```
## Posterior predictive checks ?


### Prior sensitivity analysis 
 - Try with different priors
 
 
 
## Discussion 

## Conclusion

## Self-reflection 